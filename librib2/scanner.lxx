/* -------------- declaration section -------------- */

%{

#ifdef	WIN32
extern "C" int isatty(int);
#pragma warning(disable : 4786)
#pragma warning(disable : 4102)
#endif

#include "aqsis.h"

#include <fstream>
#include <stack>
#include <string>
#include <vector>
#include <assert.h>
#include <stdio.h>

#include "libribtypes.h"
#ifdef	WIN32
#include "parser.hpp"
#else
#ifdef AQSIS_SYSTEM_MACOSX
#include "parser.cpp.h"
#else
#include "parser.h"
#endif /* AQSIS_SYSTEM_MACOSX */
#endif /* WIN32 */

#include "bdec.h"

namespace librib
{

extern FILE* ParseInputFile;
extern CqRibBinaryDecoder *BinaryDecoder;
extern unsigned int ParseLineNumber;
extern std::string ParseStreamName;
extern RtArchiveCallback pArchiveCallback;

bool fRequest;
bool fParams;

}; // namespace librib

static std::stack<CqRibBinaryDecoder*> StreamStack;
static std::stack<YY_BUFFER_STATE> BufferStack;
static std::stack<std::string> StreamNameStack;
static std::stack<unsigned int> LineNumberStack;

#define YY_DECL int yylex( YYSTYPE *lvalp )

static int scannerinput(char* Buffer, int MaxSize);
#undef YY_INPUT
#define YY_INPUT(buffer, result, max_size) (result = scannerinput(buffer, max_size))

//#define YY_SKIP_YYWRAP
//static int yywrap();

%}

delim				[ \t]
whitespace		{delim}+
letter				[A-Za-z]
digit					[0-9]
float				[+\-]?{digit}*(\.{digit}*)?([eE][+\-]?{digit}+)?
integer			[+\-]?{digit}+
string				\"[^"\n]*\"
eol					\r\n|\r|\n
comment			#.*
array_start		\[
array_end		\]

%s params
%x incl

/* %option lex-compat */
%option noreject

/* -------------- rules section -------------- */

%%

	if(fRequest)
	{
		BEGIN(INITIAL);
		fRequest=false;
	}

	if(fParams)
	{
		BEGIN(params);
		fParams=false;
	}

{comment}			{ 
					lvalp->stype = new char[strlen(yytext)+1]; strcpy(lvalp->stype, yytext); return COMMENT; 
				}
{eol}							{ ParseLineNumber++; }
{whitespace}			{  }

<params>{integer}		{ lvalp->itype = atoi(yytext); return INTEGER_TOKEN; }
<params>{float}			{ lvalp->ftype = atof(yytext); return FLOAT_TOKEN; }
<params>{string}		{ std::string temp(yytext); lvalp->stype = new char[temp.size()-1]; strcpy(lvalp->stype, temp.substr(1, temp.size()-2).c_str()); return STRING_TOKEN; }
<INITIAL>{integer}		{ return INVALID_VALUE; }
<INITIAL>{float}		{ return INVALID_VALUE; }
<INITIAL>{string}		{ return INVALID_VALUE; }
<INITIAL>{array_start}	{ return INVALID_VALUE; }
<INITIAL>{array_end}	{ return INVALID_VALUE; }
							
version					{ return REQUEST_TOKEN_VERSION; }
Declare					{ return REQUEST_TOKEN_DECLARE; }
FrameBegin				{ return REQUEST_TOKEN_FRAMEBEGIN; }
FrameEnd				{ return REQUEST_TOKEN_FRAMEEND; }
WorldBegin				{ return REQUEST_TOKEN_WORLDBEGIN; }
WorldEnd				{ return REQUEST_TOKEN_WORLDEND; }
Format					{ return REQUEST_TOKEN_FORMAT; }
FrameAspectRatio		{ return REQUEST_TOKEN_FRAMEASPECTRATIO; }
ScreenWindow			{ return REQUEST_TOKEN_SCREENWINDOW; }
CropWindow				{ return REQUEST_TOKEN_CROPWINDOW; }
Projection				{ return REQUEST_TOKEN_PROJECTION; }
Clipping				{ return REQUEST_TOKEN_CLIPPING; }
DepthOfField			{ return REQUEST_TOKEN_DEPTHOFFIELD; }
Shutter					{ return REQUEST_TOKEN_SHUTTER; }
PixelVariance			{ return REQUEST_TOKEN_PIXELVARIANCE; }
PixelSamples			{ return REQUEST_TOKEN_PIXELSAMPLES; }
PixelFilter				{ return REQUEST_TOKEN_PIXELFILTER; }
Exposure				{ return REQUEST_TOKEN_EXPOSURE; }
Imager					{ return REQUEST_TOKEN_IMAGER; }
Quantize				{ return REQUEST_TOKEN_QUANTIZE; }
Display					{ return REQUEST_TOKEN_DISPLAY; }
GaussianFilter			{ return REQUEST_TOKEN_GAUSSIANFILTER; }
BoxFilter				{ return REQUEST_TOKEN_BOXFILTER; }
TriangleFilter			{ return REQUEST_TOKEN_TRIANGLEFILTER; }
CatmullRomFilter		{ return REQUEST_TOKEN_CATMULLROMFILTER; }
SincFilter				{ return REQUEST_TOKEN_SINCFILTER; }
DiskFilter				{ return REQUEST_TOKEN_DISKFILTER; }
BesselFilter			{ return REQUEST_TOKEN_BESSELFILTER; }
Hider					{ return REQUEST_TOKEN_HIDER; }
ColorSamples			{ return REQUEST_TOKEN_COLORSAMPLES; }
RelativeDetail			{ return REQUEST_TOKEN_RELATIVEDETAIL; }
Option					{ return REQUEST_TOKEN_OPTION; }
AttributeBegin			{ return REQUEST_TOKEN_ATTRIBUTEBEGIN; }
AttributeEnd			{ return REQUEST_TOKEN_ATTRIBUTEEND; }
Color					{ return REQUEST_TOKEN_COLOR; }
Opacity					{ return REQUEST_TOKEN_OPACITY; }
TextureCoordinates		{ return REQUEST_TOKEN_TEXTURECOORDINATES; }
LightSource				{ return REQUEST_TOKEN_LIGHTSOURCE; }
AreaLightSource			{ return REQUEST_TOKEN_AREALIGHTSOURCE; }
Illuminate				{ return REQUEST_TOKEN_ILLUMINATE; }
Surface					{ return REQUEST_TOKEN_SURFACE; }
Atmosphere				{ return REQUEST_TOKEN_ATMOSPHERE; }
Interior				{ return REQUEST_TOKEN_INTERIOR; }
Exterior				{ return REQUEST_TOKEN_EXTERIOR; }
ShadingRate				{ return REQUEST_TOKEN_SHADINGRATE; }
ShadingInterpolation	{ return REQUEST_TOKEN_SHADINGINTERPOLATION; }
Matte					{ return REQUEST_TOKEN_MATTE; }
Blobby      			{ return REQUEST_TOKEN_BLOBBY; }
Bound					{ return REQUEST_TOKEN_BOUND; }
Detail					{ return REQUEST_TOKEN_DETAIL; }
DetailRange				{ return REQUEST_TOKEN_DETAILRANGE; }
GeometricApproximation	{ return REQUEST_TOKEN_GEOMETRICAPPROXIMATION; }
Orientation				{ return REQUEST_TOKEN_ORIENTATION; }
ReverseOrientation		{ return REQUEST_TOKEN_REVERSEORIENTATION; }
Sides					{ return REQUEST_TOKEN_SIDES; }
Identity				{ return REQUEST_TOKEN_IDENTITY; }
Transform				{ return REQUEST_TOKEN_TRANSFORM; }
ConcatTransform			{ return REQUEST_TOKEN_CONCATTRANSFORM; }
Perspective				{ return REQUEST_TOKEN_PERSPECTIVE; }
Translate				{ return REQUEST_TOKEN_TRANSLATE; }
Rotate					{ return REQUEST_TOKEN_ROTATE; }
Scale					{ return REQUEST_TOKEN_SCALE; }
Skew					{ return REQUEST_TOKEN_SKEW; }
Deformation				{ return REQUEST_TOKEN_DEFORMATION; }
Displacement			{ return REQUEST_TOKEN_DISPLACEMENT; }
CoordinateSystem		{ return REQUEST_TOKEN_COORDINATESYSTEM; }
CoordSysTransform		{ return REQUEST_TOKEN_COORDSYSTRANSFORM; }
TransformPoints			{ return REQUEST_TOKEN_TRANSFORMPOINTS; }
TransformBegin			{ return REQUEST_TOKEN_TRANSFORMBEGIN; }
TransformEnd			{ return REQUEST_TOKEN_TRANSFORMEND; }
Attribute				{ return REQUEST_TOKEN_ATTRIBUTE; }
Polygon					{ return REQUEST_TOKEN_POLYGON; }
GeneralPolygon			{ return REQUEST_TOKEN_GENERALPOLYGON; }
Curves      			{ return REQUEST_TOKEN_CURVES; }
Points      			{ return REQUEST_TOKEN_POINTS; }
PointsPolygons			{ return REQUEST_TOKEN_POINTSPOLYGONS; }
PointsGeneralPolygons	{ return REQUEST_TOKEN_POINTSGENERALPOLYGONS; }
Basis					{ return REQUEST_TOKEN_BASIS; }
Patch					{ return REQUEST_TOKEN_PATCH; }
PatchMesh				{ return REQUEST_TOKEN_PATCHMESH; }
NuPatch					{ return REQUEST_TOKEN_NUPATCH; }
TrimCurve				{ return REQUEST_TOKEN_TRIMCURVE; }
Sphere					{ return REQUEST_TOKEN_SPHERE; }
Cone					{ return REQUEST_TOKEN_CONE; }
Cylinder				{ return REQUEST_TOKEN_CYLINDER; }
Hyperboloid				{ return REQUEST_TOKEN_HYPERBOLOID; }
Paraboloid				{ return REQUEST_TOKEN_PARABOLOID; }
Disk					{ return REQUEST_TOKEN_DISK; }
Torus					{ return REQUEST_TOKEN_TORUS; }
Procedural				{ return REQUEST_TOKEN_PROCEDURAL; }
Geometry				{ return REQUEST_TOKEN_GEOMETRY; }
SolidBegin				{ return REQUEST_TOKEN_SOLIDBEGIN; }
SolidEnd				{ return REQUEST_TOKEN_SOLIDEND; }
ObjectBegin				{ return REQUEST_TOKEN_OBJECTBEGIN; }
ObjectEnd				{ return REQUEST_TOKEN_OBJECTEND; }
ObjectInstance			{ return REQUEST_TOKEN_OBJECTINSTANCE; }
MotionBegin				{ return REQUEST_TOKEN_MOTIONBEGIN; }
MotionEnd				{ return REQUEST_TOKEN_MOTIONEND; }
MakeTexture				{ return REQUEST_TOKEN_MAKETEXTURE; }
MakeBump				{ return REQUEST_TOKEN_MAKEBUMP; }
MakeLatLongEnvironment	{ return REQUEST_TOKEN_MAKELATLONGENVIRONMENT; }
MakeCubeFaceEnvironment { return REQUEST_TOKEN_MAKECUBEFACEENVIRONMENT; }
MakeShadow				{ return REQUEST_TOKEN_MAKESHADOW; }
MakeOcclusion			{ return REQUEST_TOKEN_MAKEOCCLUSION; }
ErrorHandler			{ return REQUEST_TOKEN_ERRORHANDLER; }
SubdivisionMesh			{ return REQUEST_TOKEN_SUBDIVISIONMESH; }
ReadArchive				{ return REQUEST_TOKEN_READARCHIVE; }
{letter}({letter}|{digit})*	{ return UNKNOWN_TOKEN; }
.						{ return(yytext[0]); }

<<EOF>>			{
									yyterminate();
									return EOF_TOKEN;
						}


%%

/* -------------- code section -------------- */

int yywrap()
{
	return 1;
}

static int scannerinput(char* Buffer, int MaxSize)
{
	// Sanity checks ...
	assert(BinaryDecoder);
	assert(Buffer);
	assert(MaxSize);

	int count = 0;
	if(!BinaryDecoder->eof())
		count=BinaryDecoder->read(Buffer,MaxSize);

 	return count;
}

struct yy_buffer_state* current_flex_buffer(void)
{
        return YY_CURRENT_BUFFER;
}
