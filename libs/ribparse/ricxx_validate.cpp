// Aqsis
// Copyright (C) 1997 - 2007, Paul C. Gregory
//
// Contact: pgregory@aqsis.org
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

/// \file
/// \brief Ri::Renderer interface validation
/// \author Chris Foster [chris42f (at) g mail (d0t) com]

#include "ricxx2ri.h"

#include <cfloat>
#include <stack>

#include <aqsis/util/exception.h>

namespace Aqsis {

//------------------------------------------------------------------------------
/// Class which validates API call arguments and ordering.
///
/// This class performs a few major validation tasks:
///
/// 1) The RI is stateful, and Begin/End blocks must be correctly nested.
///    In addition, most calls can only occur in the scope of a restricted set
///    of block types.  We validate this.
/// 2) Most API calls have array arguments with lenghts which depend on the
///    details of the call.  We need to validate these to avoid reading off
///    the ends of arrays, etc.  If the arrays come from the C interface, the
///    lengths will be undetermined; in this case we compute the desired
///    length.
/// 3) The values of function arguments often need to lie in a given range, we
///    check this too.
///
/// All valid calls are passed on to the wrapped Ri::Renderer instance.
class RiCxxValidate : public Ri::Filter
{
    private:
        // Scope names for Begin/End blocks
        enum ApiScope {
            Scope_BeginEnd   = 1<<0,
            Scope_Frame      = 1<<1,
            Scope_World      = 1<<2,
            Scope_Attribute  = 1<<3,
            Scope_Transform  = 1<<4,
            Scope_Solid      = 1<<5,
            Scope_Object     = 1<<6,
            Scope_Motion     = 1<<7,
            Scope_Resource   = 1<<8,
        };
        std::stack<ApiScope> m_scopeStack;

        /// Return a string corresponding to the given ApiScope
        static const char* scopeString(ApiScope s);
        /// Check that the current scope is in the set allowedScopes
        void checkScope(ApiScope allowedScopes) const;

    public:
        RiCxxValidate()
            : m_scopeStack()
        {
            m_scopeStack.push(Scope_BeginEnd);
        }

        // The following just call through to the underlying implementation.
        virtual RtVoid ArchiveRecord(RtConstToken type, const char* string)
            { outputInterface()->ArchiveRecord(type, string); }
        virtual RtVoid Error(const char* errorMessage)
            { outputInterface()->Error(errorMessage); }
        virtual RtFilterFunc GetFilterFunc(RtConstToken name) const
            { return outputInterface()->GetFilterFunc(name); }
        virtual RtConstBasis* GetBasis(RtConstToken name) const
            { return outputInterface()->GetBasis(name); }
        virtual RtErrorFunc GetErrorFunc(RtConstToken name) const
            { return outputInterface()->GetErrorFunc(name); }
        virtual RtProcSubdivFunc GetProcSubdivFunc(RtConstToken name) const
            { return outputInterface()->GetProcSubdivFunc(name); }
        virtual TypeSpec GetDeclaration(RtConstToken token,
                                        const char** nameBegin,
                                        const char** nameEnd)
            { return outputInterface()->GetDeclaration(token, nameBegin, nameEnd); }

        // Code generator for autogenerated method declarations
        /*[[[cog
        from cogutils import *

        riXml = parseXmlTree('ri.xml')

        for p in riXml.findall('Procedures/Procedure'):
            if p.haschild('Rib'):
                decl = 'virtual %s;' % (riCxxMethodDecl(p),)
                cog.outl(wrapDecl(decl, 72, wrapIndent=20))
        ]]]*/
        virtual RtToken Declare(RtConstString name, RtConstString declaration);
        virtual RtVoid FrameBegin(RtInt number);
        virtual RtVoid FrameEnd();
        virtual RtVoid WorldBegin();
        virtual RtVoid WorldEnd();
        virtual RtVoid IfBegin(RtConstString condition);
        virtual RtVoid ElseIf(RtConstString condition);
        virtual RtVoid Else();
        virtual RtVoid IfEnd();
        virtual RtVoid Format(RtInt xresolution, RtInt yresolution,
                            RtFloat pixelaspectratio);
        virtual RtVoid FrameAspectRatio(RtFloat frameratio);
        virtual RtVoid ScreenWindow(RtFloat left, RtFloat right, RtFloat bottom,
                            RtFloat top);
        virtual RtVoid CropWindow(RtFloat xmin, RtFloat xmax, RtFloat ymin,
                            RtFloat ymax);
        virtual RtVoid Projection(RtConstToken name, const ParamList& pList);
        virtual RtVoid Clipping(RtFloat cnear, RtFloat cfar);
        virtual RtVoid ClippingPlane(RtFloat x, RtFloat y, RtFloat z,
                            RtFloat nx, RtFloat ny, RtFloat nz);
        virtual RtVoid DepthOfField(RtFloat fstop, RtFloat focallength,
                            RtFloat focaldistance);
        virtual RtVoid Shutter(RtFloat opentime, RtFloat closetime);
        virtual RtVoid PixelVariance(RtFloat variance);
        virtual RtVoid PixelSamples(RtFloat xsamples, RtFloat ysamples);
        virtual RtVoid PixelFilter(RtFilterFunc function, RtFloat xwidth,
                            RtFloat ywidth);
        virtual RtVoid Exposure(RtFloat gain, RtFloat gamma);
        virtual RtVoid Imager(RtConstToken name, const ParamList& pList);
        virtual RtVoid Quantize(RtConstToken type, RtInt one, RtInt min,
                            RtInt max, RtFloat ditheramplitude);
        virtual RtVoid Display(RtConstToken name, RtConstToken type,
                            RtConstToken mode, const ParamList& pList);
        virtual RtVoid Hider(RtConstToken name, const ParamList& pList);
        virtual RtVoid ColorSamples(const FloatArray& nRGB,
                            const FloatArray& RGBn);
        virtual RtVoid RelativeDetail(RtFloat relativedetail);
        virtual RtVoid Option(RtConstToken name, const ParamList& pList);
        virtual RtVoid AttributeBegin();
        virtual RtVoid AttributeEnd();
        virtual RtVoid Color(RtConstColor Cq);
        virtual RtVoid Opacity(RtConstColor Os);
        virtual RtVoid TextureCoordinates(RtFloat s1, RtFloat t1, RtFloat s2,
                            RtFloat t2, RtFloat s3, RtFloat t3, RtFloat s4,
                            RtFloat t4);
        virtual RtLightHandle LightSource(RtConstToken name,
                            const ParamList& pList);
        virtual RtLightHandle AreaLightSource(RtConstToken name,
                            const ParamList& pList);
        virtual RtVoid Illuminate(RtLightHandle light, RtBoolean onoff);
        virtual RtVoid Surface(RtConstToken name, const ParamList& pList);
        virtual RtVoid Displacement(RtConstToken name, const ParamList& pList);
        virtual RtVoid Atmosphere(RtConstToken name, const ParamList& pList);
        virtual RtVoid Interior(RtConstToken name, const ParamList& pList);
        virtual RtVoid Exterior(RtConstToken name, const ParamList& pList);
        virtual RtVoid ShaderLayer(RtConstToken type, RtConstToken name,
                            RtConstToken layername, const ParamList& pList);
        virtual RtVoid ConnectShaderLayers(RtConstToken type,
                            RtConstToken layer1, RtConstToken variable1,
                            RtConstToken layer2, RtConstToken variable2);
        virtual RtVoid ShadingRate(RtFloat size);
        virtual RtVoid ShadingInterpolation(RtConstToken type);
        virtual RtVoid Matte(RtBoolean onoff);
        virtual RtVoid Bound(RtConstBound bound);
        virtual RtVoid Detail(RtConstBound bound);
        virtual RtVoid DetailRange(RtFloat offlow, RtFloat onlow,
                            RtFloat onhigh, RtFloat offhigh);
        virtual RtVoid GeometricApproximation(RtConstToken type,
                            RtFloat value);
        virtual RtVoid Orientation(RtConstToken orientation);
        virtual RtVoid ReverseOrientation();
        virtual RtVoid Sides(RtInt nsides);
        virtual RtVoid Identity();
        virtual RtVoid Transform(RtConstMatrix transform);
        virtual RtVoid ConcatTransform(RtConstMatrix transform);
        virtual RtVoid Perspective(RtFloat fov);
        virtual RtVoid Translate(RtFloat dx, RtFloat dy, RtFloat dz);
        virtual RtVoid Rotate(RtFloat angle, RtFloat dx, RtFloat dy,
                            RtFloat dz);
        virtual RtVoid Scale(RtFloat sx, RtFloat sy, RtFloat sz);
        virtual RtVoid Skew(RtFloat angle, RtFloat dx1, RtFloat dy1,
                            RtFloat dz1, RtFloat dx2, RtFloat dy2,
                            RtFloat dz2);
        virtual RtVoid CoordinateSystem(RtConstToken space);
        virtual RtVoid CoordSysTransform(RtConstToken space);
        virtual RtVoid TransformBegin();
        virtual RtVoid TransformEnd();
        virtual RtVoid Resource(RtConstToken handle, RtConstToken type,
                            const ParamList& pList);
        virtual RtVoid ResourceBegin();
        virtual RtVoid ResourceEnd();
        virtual RtVoid Attribute(RtConstToken name, const ParamList& pList);
        virtual RtVoid Polygon(const ParamList& pList);
        virtual RtVoid GeneralPolygon(const IntArray& nverts,
                            const ParamList& pList);
        virtual RtVoid PointsPolygons(const IntArray& nverts,
                            const IntArray& verts, const ParamList& pList);
        virtual RtVoid PointsGeneralPolygons(const IntArray& nloops,
                            const IntArray& nverts, const IntArray& verts,
                            const ParamList& pList);
        virtual RtVoid Basis(RtConstBasis ubasis, RtInt ustep,
                            RtConstBasis vbasis, RtInt vstep);
        virtual RtVoid Patch(RtConstToken type, const ParamList& pList);
        virtual RtVoid PatchMesh(RtConstToken type, RtInt nu,
                            RtConstToken uwrap, RtInt nv, RtConstToken vwrap,
                            const ParamList& pList);
        virtual RtVoid NuPatch(RtInt nu, RtInt uorder, const FloatArray& uknot,
                            RtFloat umin, RtFloat umax, RtInt nv, RtInt vorder,
                            const FloatArray& vknot, RtFloat vmin, RtFloat vmax,
                            const ParamList& pList);
        virtual RtVoid TrimCurve(const IntArray& ncurves, const IntArray& order,
                            const FloatArray& knot, const FloatArray& min,
                            const FloatArray& max, const IntArray& n,
                            const FloatArray& u, const FloatArray& v,
                            const FloatArray& w);
        virtual RtVoid SubdivisionMesh(RtConstToken scheme,
                            const IntArray& nvertices, const IntArray& vertices,
                            const TokenArray& tags, const IntArray& nargs,
                            const IntArray& intargs,
                            const FloatArray& floatargs,
                            const ParamList& pList);
        virtual RtVoid Sphere(RtFloat radius, RtFloat zmin, RtFloat zmax,
                            RtFloat thetamax, const ParamList& pList);
        virtual RtVoid Cone(RtFloat height, RtFloat radius, RtFloat thetamax,
                            const ParamList& pList);
        virtual RtVoid Cylinder(RtFloat radius, RtFloat zmin, RtFloat zmax,
                            RtFloat thetamax, const ParamList& pList);
        virtual RtVoid Hyperboloid(RtConstPoint point1, RtConstPoint point2,
                            RtFloat thetamax, const ParamList& pList);
        virtual RtVoid Paraboloid(RtFloat rmax, RtFloat zmin, RtFloat zmax,
                            RtFloat thetamax, const ParamList& pList);
        virtual RtVoid Disk(RtFloat height, RtFloat radius, RtFloat thetamax,
                            const ParamList& pList);
        virtual RtVoid Torus(RtFloat majorrad, RtFloat minorrad, RtFloat phimin,
                            RtFloat phimax, RtFloat thetamax,
                            const ParamList& pList);
        virtual RtVoid Points(const ParamList& pList);
        virtual RtVoid Curves(RtConstToken type, const IntArray& nvertices,
                            RtConstToken wrap, const ParamList& pList);
        virtual RtVoid Blobby(RtInt nleaf, const IntArray& code,
                            const FloatArray& flt, const TokenArray& str,
                            const ParamList& pList);
        virtual RtVoid Procedural(RtPointer data, RtConstBound bound,
                            RtProcSubdivFunc refineproc,
                            RtProcFreeFunc freeproc);
        virtual RtVoid Geometry(RtConstToken type, const ParamList& pList);
        virtual RtVoid SolidBegin(RtConstToken type);
        virtual RtVoid SolidEnd();
        virtual RtObjectHandle ObjectBegin();
        virtual RtVoid ObjectEnd();
        virtual RtVoid ObjectInstance(RtObjectHandle handle);
        virtual RtVoid MotionBegin(const FloatArray& times);
        virtual RtVoid MotionEnd();
        virtual RtVoid MakeTexture(RtConstString imagefile,
                            RtConstString texturefile, RtConstToken swrap,
                            RtConstToken twrap, RtFilterFunc filterfunc,
                            RtFloat swidth, RtFloat twidth,
                            const ParamList& pList);
        virtual RtVoid MakeLatLongEnvironment(RtConstString imagefile,
                            RtConstString reflfile, RtFilterFunc filterfunc,
                            RtFloat swidth, RtFloat twidth,
                            const ParamList& pList);
        virtual RtVoid MakeCubeFaceEnvironment(RtConstString px,
                            RtConstString nx, RtConstString py,
                            RtConstString ny, RtConstString pz,
                            RtConstString nz, RtConstString reflfile,
                            RtFloat fov, RtFilterFunc filterfunc,
                            RtFloat swidth, RtFloat twidth,
                            const ParamList& pList);
        virtual RtVoid MakeShadow(RtConstString picfile,
                            RtConstString shadowfile, const ParamList& pList);
        virtual RtVoid MakeOcclusion(const StringArray& picfiles,
                            RtConstString shadowfile, const ParamList& pList);
        virtual RtVoid ErrorHandler(RtErrorFunc handler);
        virtual RtVoid ReadArchive(RtConstToken name,
                            RtArchiveCallback callback,
                            const ParamList& pList);
        //[[[end]]]
};

const char* RiCxxValidate::scopeString(ApiScope s)
{
    switch(s)
    {
        case Scope_BeginEnd:   return "Outer";
        case Scope_Frame:      return "Frame";
        case Scope_World:      return "World";
        case Scope_Attribute:  return "Attribute";
        case Scope_Transform:  return "Transform";
        case Scope_Solid:      return "Solid";
        case Scope_Object:     return "Object";
        case Scope_Motion:     return "Motion";
        case Scope_Resource:   return "Resource";
    }
    assert(0 && "unknown scope (FIXME)");
    return "unknown scope (FIXME)";
}

void RiCxxValidate::checkScope(ApiScope allowedScopes) const
{
    ApiScope currScope = m_scopeStack.top();
    if(!(currScope & allowedScopes))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_IllState,
            "invalid in " << scopeString(currScope) << " scope ");
    }
}

//------------------------------------------------------------------------------
// Autogenerated method implementations

#ifndef RI_EPSILON
#   define RI_EPSILON FLT_EPSILON
#endif

/*[[[cog
from cogutils import *
from Cheetah.Template import Template
import re

customImpl = set((
))

# scopes which are ignored during validation.
irrelevantScopes = set((
    'Outside',   #< only relevant to C API
    'If',        #< XML needs updating (FIXME?)
    'Resource',  #< not fully implemented yet (TODO)
))

def wrapperCallArgList(procXml):
    args = [arg.findtext('Name') for arg in
            ribArgs(procXml.findall('Arguments/Argument'))]
    if procXml.haschild('Arguments/ParamList'):
        args += ['pList']
    return args

rangeCheckOps = {
    'gt' : '>',
    'lt' : '<',
    'ge' : '>=',
    'le' : '<=',
    'ne' : '!='
}

methodTemplate = '''
$wrapDecl($riCxxMethodDecl($proc, className='RiCxxValidate'), 80)
{
#if $doScopeCheck
    checkScope(ApiScope(${' | '.join($validScopeNames)}));
#end if
#if $pushScope is not None
    m_scopeStack.push($pushScope);
#end if
#if $popScope is not None
    assert(m_scopeStack.top() == $popScope);
    m_scopeStack.pop();
#end if
#for $arg in $args
  #set $range = $arg.find('Range')
  #if $range is not None:
    #for $check in $range.getchildren()
    #set $argName = $arg.findtext('Name')
    #set $op = $rangeCheckOps[$check.tag]
    #set $limit = $check.text
    #set $limitIsConst = $re.match('([0-9.]*|RI_EPSILON)$', $limit)
    if(!($argName $op $limit))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check $argName $op $limit failed: "
    #if $limitIsConst
            "[$argName = " << $argName << "]"
    #else
            "[$argName = " << $argName << ", " << "$limit = " << $limit << "]";
    #end if
        );
    }
    #end for
  #end if
#end for
    return outputInterface()->${procName}(${', '.join($wrapperCallArgList($proc))});
}
'''


for proc in riXml.findall('Procedures/Procedure'):
    if proc.haschild('Rib') and proc.findtext('Name') not in customImpl:
        args = ribArgs(proc.findall('Arguments/Argument'))
        procName = proc.findtext('Name')
        validScopeNames = set(['Scope_' + s.tag for s in
                               proc.findall('ValidScope/'+'*')
                               if s.tag not in irrelevantScopes])
        doScopeCheck = len(validScopeNames) > 0
        pushScope = None
        if procName.endswith('Begin'):
            scopeName = procName[:-5]
            if scopeName not in irrelevantScopes:
                pushScope = 'Scope_' + scopeName
        popScope = None
        if procName.endswith('End'):
            scopeName = procName[:-3]
            if scopeName not in irrelevantScopes:
                popScope = 'Scope_' + scopeName
        cog.out(str(Template(methodTemplate, searchList=locals())));

]]]*/

RtToken RiCxxValidate::Declare(RtConstString name, RtConstString declaration)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Declare(name, declaration);
}

RtVoid RiCxxValidate::FrameBegin(RtInt number)
{
    checkScope(ApiScope(Scope_BeginEnd));
    m_scopeStack.push(Scope_Frame);
    return outputInterface()->FrameBegin(number);
}

RtVoid RiCxxValidate::FrameEnd()
{
    checkScope(ApiScope(Scope_Frame));
    assert(m_scopeStack.top() == Scope_Frame);
    m_scopeStack.pop();
    return outputInterface()->FrameEnd();
}

RtVoid RiCxxValidate::WorldBegin()
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    m_scopeStack.push(Scope_World);
    return outputInterface()->WorldBegin();
}

RtVoid RiCxxValidate::WorldEnd()
{
    checkScope(ApiScope(Scope_World));
    assert(m_scopeStack.top() == Scope_World);
    m_scopeStack.pop();
    return outputInterface()->WorldEnd();
}

RtVoid RiCxxValidate::IfBegin(RtConstString condition)
{
    return outputInterface()->IfBegin(condition);
}

RtVoid RiCxxValidate::ElseIf(RtConstString condition)
{
    return outputInterface()->ElseIf(condition);
}

RtVoid RiCxxValidate::Else()
{
    return outputInterface()->Else();
}

RtVoid RiCxxValidate::IfEnd()
{
    return outputInterface()->IfEnd();
}

RtVoid RiCxxValidate::Format(RtInt xresolution, RtInt yresolution,
                             RtFloat pixelaspectratio)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(xresolution != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check xresolution != 0 failed: "
            "[xresolution = " << xresolution << "]"
        );
    }
    if(!(yresolution != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check yresolution != 0 failed: "
            "[yresolution = " << yresolution << "]"
        );
    }
    if(!(pixelaspectratio != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check pixelaspectratio != 0 failed: "
            "[pixelaspectratio = " << pixelaspectratio << "]"
        );
    }
    return outputInterface()->Format(xresolution, yresolution, pixelaspectratio);
}

RtVoid RiCxxValidate::FrameAspectRatio(RtFloat frameratio)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(frameratio > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check frameratio > 0 failed: "
            "[frameratio = " << frameratio << "]"
        );
    }
    return outputInterface()->FrameAspectRatio(frameratio);
}

RtVoid RiCxxValidate::ScreenWindow(RtFloat left, RtFloat right, RtFloat bottom,
                                   RtFloat top)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(left < right))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check left < right failed: "
            "[left = " << left << ", " << "right = " << right << "]";
        );
    }
    if(!(bottom < top))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check bottom < top failed: "
            "[bottom = " << bottom << ", " << "top = " << top << "]";
        );
    }
    return outputInterface()->ScreenWindow(left, right, bottom, top);
}

RtVoid RiCxxValidate::CropWindow(RtFloat xmin, RtFloat xmax, RtFloat ymin,
                                 RtFloat ymax)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(xmin >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check xmin >= 0 failed: "
            "[xmin = " << xmin << "]"
        );
    }
    if(!(xmin < xmax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check xmin < xmax failed: "
            "[xmin = " << xmin << ", " << "xmax = " << xmax << "]";
        );
    }
    if(!(xmax <= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check xmax <= 1 failed: "
            "[xmax = " << xmax << "]"
        );
    }
    if(!(ymin >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ymin >= 0 failed: "
            "[ymin = " << ymin << "]"
        );
    }
    if(!(ymin < ymax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ymin < ymax failed: "
            "[ymin = " << ymin << ", " << "ymax = " << ymax << "]";
        );
    }
    if(!(ymax <= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ymax <= 1 failed: "
            "[ymax = " << ymax << "]"
        );
    }
    return outputInterface()->CropWindow(xmin, xmax, ymin, ymax);
}

RtVoid RiCxxValidate::Projection(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->Projection(name, pList);
}

RtVoid RiCxxValidate::Clipping(RtFloat cnear, RtFloat cfar)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(cnear >= RI_EPSILON))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check cnear >= RI_EPSILON failed: "
            "[cnear = " << cnear << "]"
        );
    }
    if(!(cfar > cnear))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check cfar > cnear failed: "
            "[cfar = " << cfar << ", " << "cnear = " << cnear << "]";
        );
    }
    return outputInterface()->Clipping(cnear, cfar);
}

RtVoid RiCxxValidate::ClippingPlane(RtFloat x, RtFloat y, RtFloat z, RtFloat nx,
                                    RtFloat ny, RtFloat nz)
{
    return outputInterface()->ClippingPlane(x, y, z, nx, ny, nz);
}

RtVoid RiCxxValidate::DepthOfField(RtFloat fstop, RtFloat focallength,
                                   RtFloat focaldistance)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(fstop > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check fstop > 0 failed: "
            "[fstop = " << fstop << "]"
        );
    }
    if(!(focallength > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check focallength > 0 failed: "
            "[focallength = " << focallength << "]"
        );
    }
    if(!(focaldistance > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check focaldistance > 0 failed: "
            "[focaldistance = " << focaldistance << "]"
        );
    }
    return outputInterface()->DepthOfField(fstop, focallength, focaldistance);
}

RtVoid RiCxxValidate::Shutter(RtFloat opentime, RtFloat closetime)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(opentime <= closetime))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check opentime <= closetime failed: "
            "[opentime = " << opentime << ", " << "closetime = " << closetime << "]";
        );
    }
    return outputInterface()->Shutter(opentime, closetime);
}

RtVoid RiCxxValidate::PixelVariance(RtFloat variance)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(variance >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check variance >= 0 failed: "
            "[variance = " << variance << "]"
        );
    }
    return outputInterface()->PixelVariance(variance);
}

RtVoid RiCxxValidate::PixelSamples(RtFloat xsamples, RtFloat ysamples)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(xsamples >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check xsamples >= 1 failed: "
            "[xsamples = " << xsamples << "]"
        );
    }
    if(!(ysamples >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ysamples >= 1 failed: "
            "[ysamples = " << ysamples << "]"
        );
    }
    return outputInterface()->PixelSamples(xsamples, ysamples);
}

RtVoid RiCxxValidate::PixelFilter(RtFilterFunc function, RtFloat xwidth,
                                  RtFloat ywidth)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(xwidth > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check xwidth > 0 failed: "
            "[xwidth = " << xwidth << "]"
        );
    }
    if(!(ywidth > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ywidth > 0 failed: "
            "[ywidth = " << ywidth << "]"
        );
    }
    return outputInterface()->PixelFilter(function, xwidth, ywidth);
}

RtVoid RiCxxValidate::Exposure(RtFloat gain, RtFloat gamma)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(gain > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check gain > 0 failed: "
            "[gain = " << gain << "]"
        );
    }
    if(!(gamma > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check gamma > 0 failed: "
            "[gamma = " << gamma << "]"
        );
    }
    return outputInterface()->Exposure(gain, gamma);
}

RtVoid RiCxxValidate::Imager(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->Imager(name, pList);
}

RtVoid RiCxxValidate::Quantize(RtConstToken type, RtInt one, RtInt min,
                               RtInt max, RtFloat ditheramplitude)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(one >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check one >= 0 failed: "
            "[one = " << one << "]"
        );
    }
    if(!(min >= max))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check min >= max failed: "
            "[min = " << min << ", " << "max = " << max << "]";
        );
    }
    if(!(ditheramplitude >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ditheramplitude >= 0 failed: "
            "[ditheramplitude = " << ditheramplitude << "]"
        );
    }
    return outputInterface()->Quantize(type, one, min, max, ditheramplitude);
}

RtVoid RiCxxValidate::Display(RtConstToken name, RtConstToken type,
                              RtConstToken mode, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->Display(name, type, mode, pList);
}

RtVoid RiCxxValidate::Hider(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->Hider(name, pList);
}

RtVoid RiCxxValidate::ColorSamples(const FloatArray& nRGB,
                                   const FloatArray& RGBn)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->ColorSamples(nRGB, RGBn);
}

RtVoid RiCxxValidate::RelativeDetail(RtFloat relativedetail)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(relativedetail >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check relativedetail >= 0 failed: "
            "[relativedetail = " << relativedetail << "]"
        );
    }
    return outputInterface()->RelativeDetail(relativedetail);
}

RtVoid RiCxxValidate::Option(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->Option(name, pList);
}

RtVoid RiCxxValidate::AttributeBegin()
{
    checkScope(ApiScope(Scope_Transform | Scope_Solid | Scope_Attribute | Scope_World | Scope_Object));
    m_scopeStack.push(Scope_Attribute);
    return outputInterface()->AttributeBegin();
}

RtVoid RiCxxValidate::AttributeEnd()
{
    checkScope(ApiScope(Scope_Attribute));
    assert(m_scopeStack.top() == Scope_Attribute);
    m_scopeStack.pop();
    return outputInterface()->AttributeEnd();
}

RtVoid RiCxxValidate::Color(RtConstColor Cq)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Color(Cq);
}

RtVoid RiCxxValidate::Opacity(RtConstColor Os)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Opacity(Os);
}

RtVoid RiCxxValidate::TextureCoordinates(RtFloat s1, RtFloat t1, RtFloat s2,
                                         RtFloat t2, RtFloat s3, RtFloat t3,
                                         RtFloat s4, RtFloat t4)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->TextureCoordinates(s1, t1, s2, t2, s3, t3, s4, t4);
}

RtLightHandle RiCxxValidate::LightSource(RtConstToken name,
                                         const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->LightSource(name, pList);
}

RtLightHandle RiCxxValidate::AreaLightSource(RtConstToken name,
                                             const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->AreaLightSource(name, pList);
}

RtVoid RiCxxValidate::Illuminate(RtLightHandle light, RtBoolean onoff)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Illuminate(light, onoff);
}

RtVoid RiCxxValidate::Surface(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Surface(name, pList);
}

RtVoid RiCxxValidate::Displacement(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Displacement(name, pList);
}

RtVoid RiCxxValidate::Atmosphere(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Atmosphere(name, pList);
}

RtVoid RiCxxValidate::Interior(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Interior(name, pList);
}

RtVoid RiCxxValidate::Exterior(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Exterior(name, pList);
}

RtVoid RiCxxValidate::ShaderLayer(RtConstToken type, RtConstToken name,
                                  RtConstToken layername,
                                  const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->ShaderLayer(type, name, layername, pList);
}

RtVoid RiCxxValidate::ConnectShaderLayers(RtConstToken type,
                                          RtConstToken layer1,
                                          RtConstToken variable1,
                                          RtConstToken layer2,
                                          RtConstToken variable2)
{
    return outputInterface()->ConnectShaderLayers(type, layer1, variable1, layer2, variable2);
}

RtVoid RiCxxValidate::ShadingRate(RtFloat size)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    if(!(size > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check size > 0 failed: "
            "[size = " << size << "]"
        );
    }
    return outputInterface()->ShadingRate(size);
}

RtVoid RiCxxValidate::ShadingInterpolation(RtConstToken type)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->ShadingInterpolation(type);
}

RtVoid RiCxxValidate::Matte(RtBoolean onoff)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Matte(onoff);
}

RtVoid RiCxxValidate::Bound(RtConstBound bound)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Bound(bound);
}

RtVoid RiCxxValidate::Detail(RtConstBound bound)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Detail(bound);
}

RtVoid RiCxxValidate::DetailRange(RtFloat offlow, RtFloat onlow, RtFloat onhigh,
                                  RtFloat offhigh)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    if(!(offlow <= onlow))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check offlow <= onlow failed: "
            "[offlow = " << offlow << ", " << "onlow = " << onlow << "]";
        );
    }
    if(!(onlow <= onhigh))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check onlow <= onhigh failed: "
            "[onlow = " << onlow << ", " << "onhigh = " << onhigh << "]";
        );
    }
    if(!(onhigh <= offhigh))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check onhigh <= offhigh failed: "
            "[onhigh = " << onhigh << ", " << "offhigh = " << offhigh << "]";
        );
    }
    return outputInterface()->DetailRange(offlow, onlow, onhigh, offhigh);
}

RtVoid RiCxxValidate::GeometricApproximation(RtConstToken type, RtFloat value)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    if(!(value >= 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check value >= 0 failed: "
            "[value = " << value << "]"
        );
    }
    return outputInterface()->GeometricApproximation(type, value);
}

RtVoid RiCxxValidate::Orientation(RtConstToken orientation)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Orientation(orientation);
}

RtVoid RiCxxValidate::ReverseOrientation()
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->ReverseOrientation();
}

RtVoid RiCxxValidate::Sides(RtInt nsides)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Sides(nsides);
}

RtVoid RiCxxValidate::Identity()
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Identity();
}

RtVoid RiCxxValidate::Transform(RtConstMatrix transform)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Transform(transform);
}

RtVoid RiCxxValidate::ConcatTransform(RtConstMatrix transform)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->ConcatTransform(transform);
}

RtVoid RiCxxValidate::Perspective(RtFloat fov)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Perspective(fov);
}

RtVoid RiCxxValidate::Translate(RtFloat dx, RtFloat dy, RtFloat dz)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Translate(dx, dy, dz);
}

RtVoid RiCxxValidate::Rotate(RtFloat angle, RtFloat dx, RtFloat dy, RtFloat dz)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Rotate(angle, dx, dy, dz);
}

RtVoid RiCxxValidate::Scale(RtFloat sx, RtFloat sy, RtFloat sz)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Scale(sx, sy, sz);
}

RtVoid RiCxxValidate::Skew(RtFloat angle, RtFloat dx1, RtFloat dy1, RtFloat dz1,
                           RtFloat dx2, RtFloat dy2, RtFloat dz2)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Skew(angle, dx1, dy1, dz1, dx2, dy2, dz2);
}

RtVoid RiCxxValidate::CoordinateSystem(RtConstToken space)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame));
    return outputInterface()->CoordinateSystem(space);
}

RtVoid RiCxxValidate::CoordSysTransform(RtConstToken space)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->CoordSysTransform(space);
}

RtVoid RiCxxValidate::TransformBegin()
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame));
    m_scopeStack.push(Scope_Transform);
    return outputInterface()->TransformBegin();
}

RtVoid RiCxxValidate::TransformEnd()
{
    checkScope(ApiScope(Scope_Transform));
    assert(m_scopeStack.top() == Scope_Transform);
    m_scopeStack.pop();
    return outputInterface()->TransformEnd();
}

RtVoid RiCxxValidate::Resource(RtConstToken handle, RtConstToken type,
                               const ParamList& pList)
{
    return outputInterface()->Resource(handle, type, pList);
}

RtVoid RiCxxValidate::ResourceBegin()
{
    return outputInterface()->ResourceBegin();
}

RtVoid RiCxxValidate::ResourceEnd()
{
    return outputInterface()->ResourceEnd();
}

RtVoid RiCxxValidate::Attribute(RtConstToken name, const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->Attribute(name, pList);
}

RtVoid RiCxxValidate::Polygon(const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->Polygon(pList);
}

RtVoid RiCxxValidate::GeneralPolygon(const IntArray& nverts,
                                     const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->GeneralPolygon(nverts, pList);
}

RtVoid RiCxxValidate::PointsPolygons(const IntArray& nverts,
                                     const IntArray& verts,
                                     const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->PointsPolygons(nverts, verts, pList);
}

RtVoid RiCxxValidate::PointsGeneralPolygons(const IntArray& nloops,
                                            const IntArray& nverts,
                                            const IntArray& verts,
                                            const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->PointsGeneralPolygons(nloops, nverts, verts, pList);
}

RtVoid RiCxxValidate::Basis(RtConstBasis ubasis, RtInt ustep,
                            RtConstBasis vbasis, RtInt vstep)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    if(!(ustep > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check ustep > 0 failed: "
            "[ustep = " << ustep << "]"
        );
    }
    if(!(vstep > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check vstep > 0 failed: "
            "[vstep = " << vstep << "]"
        );
    }
    return outputInterface()->Basis(ubasis, ustep, vbasis, vstep);
}

RtVoid RiCxxValidate::Patch(RtConstToken type, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->Patch(type, pList);
}

RtVoid RiCxxValidate::PatchMesh(RtConstToken type, RtInt nu, RtConstToken uwrap,
                                RtInt nv, RtConstToken vwrap,
                                const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(nu > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check nu > 0 failed: "
            "[nu = " << nu << "]"
        );
    }
    if(!(nv > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check nv > 0 failed: "
            "[nv = " << nv << "]"
        );
    }
    return outputInterface()->PatchMesh(type, nu, uwrap, nv, vwrap, pList);
}

RtVoid RiCxxValidate::NuPatch(RtInt nu, RtInt uorder, const FloatArray& uknot,
                              RtFloat umin, RtFloat umax, RtInt nv,
                              RtInt vorder, const FloatArray& vknot,
                              RtFloat vmin, RtFloat vmax,
                              const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(nu > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check nu > 0 failed: "
            "[nu = " << nu << "]"
        );
    }
    if(!(uorder > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check uorder > 0 failed: "
            "[uorder = " << uorder << "]"
        );
    }
    if(!(umin < umax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check umin < umax failed: "
            "[umin = " << umin << ", " << "umax = " << umax << "]";
        );
    }
    if(!(nv > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check nv > 0 failed: "
            "[nv = " << nv << "]"
        );
    }
    if(!(vorder > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check vorder > 0 failed: "
            "[vorder = " << vorder << "]"
        );
    }
    if(!(vmin < vmax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check vmin < vmax failed: "
            "[vmin = " << vmin << ", " << "vmax = " << vmax << "]";
        );
    }
    return outputInterface()->NuPatch(nu, uorder, uknot, umin, umax, nv, vorder, vknot, vmin, vmax, pList);
}

RtVoid RiCxxValidate::TrimCurve(const IntArray& ncurves, const IntArray& order,
                                const FloatArray& knot, const FloatArray& min,
                                const FloatArray& max, const IntArray& n,
                                const FloatArray& u, const FloatArray& v,
                                const FloatArray& w)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->TrimCurve(ncurves, order, knot, min, max, n, u, v, w);
}

RtVoid RiCxxValidate::SubdivisionMesh(RtConstToken scheme,
                                      const IntArray& nvertices,
                                      const IntArray& vertices,
                                      const TokenArray& tags,
                                      const IntArray& nargs,
                                      const IntArray& intargs,
                                      const FloatArray& floatargs,
                                      const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->SubdivisionMesh(scheme, nvertices, vertices, tags, nargs, intargs, floatargs, pList);
}

RtVoid RiCxxValidate::Sphere(RtFloat radius, RtFloat zmin, RtFloat zmax,
                             RtFloat thetamax, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(radius != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check radius != 0 failed: "
            "[radius = " << radius << "]"
        );
    }
    if(!(zmin >= -abs(radius)))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check zmin >= -abs(radius) failed: "
            "[zmin = " << zmin << ", " << "-abs(radius) = " << -abs(radius) << "]";
        );
    }
    if(!(zmin < zmax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check zmin < zmax failed: "
            "[zmin = " << zmin << ", " << "zmax = " << zmax << "]";
        );
    }
    if(!(zmax <= abs(radius)))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check zmax <= abs(radius) failed: "
            "[zmax = " << zmax << ", " << "abs(radius) = " << abs(radius) << "]";
        );
    }
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Sphere(radius, zmin, zmax, thetamax, pList);
}

RtVoid RiCxxValidate::Cone(RtFloat height, RtFloat radius, RtFloat thetamax,
                           const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(height != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check height != 0 failed: "
            "[height = " << height << "]"
        );
    }
    if(!(radius != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check radius != 0 failed: "
            "[radius = " << radius << "]"
        );
    }
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Cone(height, radius, thetamax, pList);
}

RtVoid RiCxxValidate::Cylinder(RtFloat radius, RtFloat zmin, RtFloat zmax,
                               RtFloat thetamax, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(radius != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check radius != 0 failed: "
            "[radius = " << radius << "]"
        );
    }
    if(!(zmin < zmax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check zmin < zmax failed: "
            "[zmin = " << zmin << ", " << "zmax = " << zmax << "]";
        );
    }
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Cylinder(radius, zmin, zmax, thetamax, pList);
}

RtVoid RiCxxValidate::Hyperboloid(RtConstPoint point1, RtConstPoint point2,
                                  RtFloat thetamax, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Hyperboloid(point1, point2, thetamax, pList);
}

RtVoid RiCxxValidate::Paraboloid(RtFloat rmax, RtFloat zmin, RtFloat zmax,
                                 RtFloat thetamax, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(rmax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check rmax != 0 failed: "
            "[rmax = " << rmax << "]"
        );
    }
    if(!(zmin < zmax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check zmin < zmax failed: "
            "[zmin = " << zmin << ", " << "zmax = " << zmax << "]";
        );
    }
    if(!(zmax > 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check zmax > 0 failed: "
            "[zmax = " << zmax << "]"
        );
    }
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Paraboloid(rmax, zmin, zmax, thetamax, pList);
}

RtVoid RiCxxValidate::Disk(RtFloat height, RtFloat radius, RtFloat thetamax,
                           const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(radius != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check radius != 0 failed: "
            "[radius = " << radius << "]"
        );
    }
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Disk(height, radius, thetamax, pList);
}

RtVoid RiCxxValidate::Torus(RtFloat majorrad, RtFloat minorrad, RtFloat phimin,
                            RtFloat phimax, RtFloat thetamax,
                            const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    if(!(majorrad != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check majorrad != 0 failed: "
            "[majorrad = " << majorrad << "]"
        );
    }
    if(!(minorrad != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check minorrad != 0 failed: "
            "[minorrad = " << minorrad << "]"
        );
    }
    if(!(phimin != phimax))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check phimin != phimax failed: "
            "[phimin = " << phimin << ", " << "phimax = " << phimax << "]";
        );
    }
    if(!(thetamax != 0))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check thetamax != 0 failed: "
            "[thetamax = " << thetamax << "]"
        );
    }
    return outputInterface()->Torus(majorrad, minorrad, phimin, phimax, thetamax, pList);
}

RtVoid RiCxxValidate::Points(const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->Points(pList);
}

RtVoid RiCxxValidate::Curves(RtConstToken type, const IntArray& nvertices,
                             RtConstToken wrap, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->Curves(type, nvertices, wrap, pList);
}

RtVoid RiCxxValidate::Blobby(RtInt nleaf, const IntArray& code,
                             const FloatArray& flt, const TokenArray& str,
                             const ParamList& pList)
{
    checkScope(ApiScope(Scope_Motion | Scope_Object | Scope_Transform | Scope_World | Scope_Attribute | Scope_Solid));
    return outputInterface()->Blobby(nleaf, code, flt, str, pList);
}

RtVoid RiCxxValidate::Procedural(RtPointer data, RtConstBound bound,
                                 RtProcSubdivFunc refineproc,
                                 RtProcFreeFunc freeproc)
{
    checkScope(ApiScope(Scope_Transform | Scope_Solid | Scope_Attribute | Scope_World | Scope_Object));
    return outputInterface()->Procedural(data, bound, refineproc, freeproc);
}

RtVoid RiCxxValidate::Geometry(RtConstToken type, const ParamList& pList)
{
    checkScope(ApiScope(Scope_Transform | Scope_Solid | Scope_Attribute | Scope_World | Scope_Object));
    return outputInterface()->Geometry(type, pList);
}

RtVoid RiCxxValidate::SolidBegin(RtConstToken type)
{
    checkScope(ApiScope(Scope_Transform | Scope_Solid | Scope_Attribute | Scope_World | Scope_Object));
    m_scopeStack.push(Scope_Solid);
    return outputInterface()->SolidBegin(type);
}

RtVoid RiCxxValidate::SolidEnd()
{
    checkScope(ApiScope(Scope_Solid));
    assert(m_scopeStack.top() == Scope_Solid);
    m_scopeStack.pop();
    return outputInterface()->SolidEnd();
}

RtObjectHandle RiCxxValidate::ObjectBegin()
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame));
    m_scopeStack.push(Scope_Object);
    return outputInterface()->ObjectBegin();
}

RtVoid RiCxxValidate::ObjectEnd()
{
    checkScope(ApiScope(Scope_Object));
    assert(m_scopeStack.top() == Scope_Object);
    m_scopeStack.pop();
    return outputInterface()->ObjectEnd();
}

RtVoid RiCxxValidate::ObjectInstance(RtObjectHandle handle)
{
    checkScope(ApiScope(Scope_Transform | Scope_Solid | Scope_Attribute | Scope_World | Scope_Object));
    return outputInterface()->ObjectInstance(handle);
}

RtVoid RiCxxValidate::MotionBegin(const FloatArray& times)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame));
    m_scopeStack.push(Scope_Motion);
    return outputInterface()->MotionBegin(times);
}

RtVoid RiCxxValidate::MotionEnd()
{
    checkScope(ApiScope(Scope_Motion));
    assert(m_scopeStack.top() == Scope_Motion);
    m_scopeStack.pop();
    return outputInterface()->MotionEnd();
}

RtVoid RiCxxValidate::MakeTexture(RtConstString imagefile,
                                  RtConstString texturefile, RtConstToken swrap,
                                  RtConstToken twrap, RtFilterFunc filterfunc,
                                  RtFloat swidth, RtFloat twidth,
                                  const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(swidth >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check swidth >= 1 failed: "
            "[swidth = " << swidth << "]"
        );
    }
    if(!(twidth >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check twidth >= 1 failed: "
            "[twidth = " << twidth << "]"
        );
    }
    return outputInterface()->MakeTexture(imagefile, texturefile, swrap, twrap, filterfunc, swidth, twidth, pList);
}

RtVoid RiCxxValidate::MakeLatLongEnvironment(RtConstString imagefile,
                                             RtConstString reflfile,
                                             RtFilterFunc filterfunc,
                                             RtFloat swidth, RtFloat twidth,
                                             const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(swidth >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check swidth >= 1 failed: "
            "[swidth = " << swidth << "]"
        );
    }
    if(!(twidth >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check twidth >= 1 failed: "
            "[twidth = " << twidth << "]"
        );
    }
    return outputInterface()->MakeLatLongEnvironment(imagefile, reflfile, filterfunc, swidth, twidth, pList);
}

RtVoid RiCxxValidate::MakeCubeFaceEnvironment(RtConstString px,
                                              RtConstString nx,
                                              RtConstString py,
                                              RtConstString ny,
                                              RtConstString pz,
                                              RtConstString nz,
                                              RtConstString reflfile,
                                              RtFloat fov,
                                              RtFilterFunc filterfunc,
                                              RtFloat swidth, RtFloat twidth,
                                              const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    if(!(swidth >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check swidth >= 1 failed: "
            "[swidth = " << swidth << "]"
        );
    }
    if(!(twidth >= 1))
    {
        AQSIS_THROW_XQERROR(XqValidation, EqE_Consistency,
            "parameter check twidth >= 1 failed: "
            "[twidth = " << twidth << "]"
        );
    }
    return outputInterface()->MakeCubeFaceEnvironment(px, nx, py, ny, pz, nz, reflfile, fov, filterfunc, swidth, twidth, pList);
}

RtVoid RiCxxValidate::MakeShadow(RtConstString picfile,
                                 RtConstString shadowfile,
                                 const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->MakeShadow(picfile, shadowfile, pList);
}

RtVoid RiCxxValidate::MakeOcclusion(const StringArray& picfiles,
                                    RtConstString shadowfile,
                                    const ParamList& pList)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_Frame));
    return outputInterface()->MakeOcclusion(picfiles, shadowfile, pList);
}

RtVoid RiCxxValidate::ErrorHandler(RtErrorFunc handler)
{
    checkScope(ApiScope(Scope_BeginEnd | Scope_World | Scope_Object | Scope_Transform | Scope_Attribute | Scope_Solid | Scope_Frame | Scope_Motion));
    return outputInterface()->ErrorHandler(handler);
}

RtVoid RiCxxValidate::ReadArchive(RtConstToken name, RtArchiveCallback callback,
                                  const ParamList& pList)
{
    return outputInterface()->ReadArchive(name, callback, pList);
}
//[[[end]]]

//------------------------------------------------------------------------------
boost::shared_ptr<Ri::Filter> createRiCxxValidate()
{
    return boost::shared_ptr<Ri::Filter>(new RiCxxValidate());
}

} // namespace Aqsis

// vi: set et:
